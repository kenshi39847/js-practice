insertAdjacentHTML()を使ってHTMLとして表示させる
HTMLを挿入したい要素を指定し、()の中には第一引数にHTMLの挿入位置、第二引数に挿入したい内容を指定する。
要素.insertAdjacentHTML('挿入位置', 挿入内容);
挿入位置は文字列扱いとなる。挿入位置は4つ指定できる。
1.beforebegin | 要素の直前に挿入
2.afterbegin  | 要素内部の最初の子要素の前に挿入
3.beforeend   | 要素内部の最後の子要素に後に挿入
4.afterend    | 要素の直後に挿入
<!-- beforebegin -->
<div>
  <!-- afterbegin -->
  HTMLを挿入
  <!-- beforeend -->
</div>
<!-- afterend -->

Google Fontsについて
Google社が提供している世界中の多くの言語のフォントを無料で利用できるWebサービス
1.http://fonts.google.com/
2.フォント名が分かっている場合はフォント名を検索
3.使いたいフォントの太さを指定（「Regular 400」等）
4.画面右側に選択したフォントが表示される。もし、画面右側にリストが出てこない場合はページ右上にある「+」マークをクリックすると表示される。
5.<link rel" ~> のコードをHTMLのhead内に記述する
(HTMLファイル)
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Kiwi+Maru&display=swap" rel="stylesheet">
6.「CSS rules to specify families」に書かれたコードをフォントに適用させたい要素に記述する
(CSSファイル)
body {
  text-align: center;
  font-family: 'Kiwi Maru', serif;
}

配列を使うと、1つの定数で複数のデータをまとめてグループ化できるので、値いが増えても定数を増やす必要はない。
配列に入れられる値のことを配列の要素という。また、各要素が入れられるスペースは「0」から始まる番号が割り振られており、この番号のことをインデックスという。

配列の書き方
「[]」を使い、その中に必要な要素を「,」で区切って記述する。一つの配列に登録できる要素の数に制限はない。
const 定数名 = [要素1, 要素2, 要素3, 要素4, 要素5];
また、格納するデータ型はなんでもOK、異なるデータが混ざっていても問題はない。
const number = [1, 20, 45, 31];
const name = ['Ken', 'Sato', '鈴木'];
const mix = ['Ken', 20, true];

配列の中身である要素を取り出す方法
配列名の定数名に続けて「[]」を書き、その中に取り出したい要素のインデックス（番号）を指定する。
const lists = [
  'strawberry.jpg',
  'lime.jpg',
  'mango.jpg',
  'lemon.jpg',
  'fig.jpg',
  'apple.jpg'
]
console.log(lists[0]);

配列を操作するメソッド
const items = ['コーヒー', '紅茶', 'ジュース'];
1.配列.pop()  配列の最後の要素を削除する
  items.pop();
  console.log(items);
  <!-- ["コーヒー","紅茶"] -->
2.配列.push(要素)  配列の最後に要素を追加する
  items.push('水');
  console.log(items);
  <!-- ["コーヒー","紅茶","ジュース","水"] -->
3.配列.shift()  配列の最初の要素を削除する
  items.shift();
  console.log(items);
  <!-- ["紅茶","ジュース"] -->
4.配列.unshift(要素)  配列の最初に要素を追加する
  items.unshift('水');
  console.log(items);
  <!-- ["水","コーヒー","紅茶","ジュース"] -->
5.配列.reverse()  配列の順序を逆にする
  console.log(items.reverse());
  <!-- ["ジュース","紅茶","コーヒー"] -->
6.配列.join(区切り文)  配列の要素を結合し、文字列として返す
  console.log(items.join('と'));
  <!-- コーヒーと紅茶とジュース -->
7.文字列.split(区切り文)  文字列から指定した文字で区切った配列を生成する
  console.log('ジュースと紅茶とコーヒー'.split('と'));
  <!-- ["ジュース","紅茶","コーヒー"] -->

同じプログラムを繰り返し実行するには「for」という構文を使う。数え始める数や繰り返す条件などを指定する。
この構文は「for構文」と呼ばれ、繰り返し行われる処理のことはループ処理ともいい、繰り返し処理1回分をループと表現する。
for(初回に実行する処理; 繰り返し条件; 各繰り返し後の処理){
  繰り返し実行する処理
}
for(let i = 1; i <= 10; i++){
  console.log(`${i}回目のこんにちは`);
}
let i = 1; (初回に実行する処理、「ループカウンター」と呼ばれ、何回目の繰り返し処理かを記憶させるためのもの)
i <= 10; (繰り返し条件、変数「i」が1ずつ加算される繰り返し処理が続き、「i」が11になると繰り返しは停止する)
i++ (各繰り返し後の処理、各繰り返し処理の後に「i」を1ずつ増やす。「i++」 = 「i += 1」 = 「i = i + 1」どれでも使える。)

「let」は値を入れておける箱のような役割をもつ。
let 変数名 = 値;
「const」と似ているが、違いとして、「const」は値の再代入ができない。
for文では1回目、2回目、3回目...と繰り返し処理されるたびに回数部分が更新されるため、再代入が可能な「let」を使用する。

配列をfor文で使う
const lists = [
  'strawberry.jpg',
  'lime.jpg',
  'mango.jpg',
  'lemon.jpg',
  'fig.jpg',
  'apple.jpg'
];
for(let i = 0; i < 6; i++){
  const content = `<div><img src="images/${lists[i]}" alt=""></div>`;
  menu.insertAdjacentHTML('beforeend', content);
}

lengthで要素の数を取得する
今後、配列の要素の数が変更されたときに、「length」で取得できる数字は自動的に更新される。
for(let i = 0; i < lists.length; i++){
  const content = `<div><img src="images/${lists[i]}" alt=""></div>`;
  menu.insertAdjacentHTML('beforeend', content);
}

常にtrueを返し続ける条件式を書いてしまうと、for文は終了できなくなる。この終了できなくなる状態を無限ループという。
無限ループが発生すると、ブラウザが一切の操作を受け付けなくなり、いずれパソコン自体がフリーズしてしまう可能性もある。
もし誤って無限ループを発生させても通常は実行したページのタブやウインドウを閉じれば問題はない。
ブラウザーが反応しなくなったときは、Ctrl + Alt + Delete でタスクマネージャーを立ち上げ、止まってしまったブラウザーを選択し、強制終了する。

中身を変更できる変数は「let」、中身が変わることのない変数は「const」を使う。箱の中身を変更することを再代入という。
let letname = 'Ken';
console.log(letname);
<!-- コンソール -->
<!-- Ken -->

let letname = 'Ken';
letname = 'Sato';
console.log(letname);
<!-- コンソール -->
<!-- Sato -->

const constname = 'Ken';
console.log(constname);
<!-- コンソール -->
<!-- Ken -->

const constname = 'Ken';
constname = 'Sato'
console.log(constname);
<!-- コンソール -->
<!-- Uncaught TypeError: Assignment to constant variable. -->

「const」のメリット
・意図せず別の値を再代入してしまうミスを防げる
・コードを読むときに、値が再代入されている可能性を考える必要がない

複数のデータをひとまとまりにしたものをオブジェクトという。
項目ごとに分かれているデータのことをプロパティといい、項目名をキー（プロパティ名）、キーに対する内容を値という。
例）オブジェクト：「ノート」
プロパティ：キー + 値
キー：「サイズ」「ページ数」「値段」
値：「A6」「150」「300」

オブジェクト、プロパティ、キー、値の書き方
const 定数名 = {
  キー1: 値1,
  キー2: 値2,
  キー3: 値3
};
オブジェクト：{～};
プロパティ：キー1: 値1, キー2: 値2, キー3: 値3,
キー：キー1, キー2, キー3
値：値1, 値2, 値3

オブジェクトの情報を取得する
1.ドット記法
オブジェクトに「.」とキーをつなげて書く方法
オブジェクト名.キー
strawberry.name
2.ブラケット記法
オブジェクト名の後に「[]」を書き、その中にキーを文字列として書く方法
オブジェクト名['キー']
strawberry['name']
基本的にはドット記法で統一する。キーを定数で指定する必要がある場合に限りブラケット記法を使う。

「window」や「document」はJavaScriptにあらかじめ用意されているオブジェクトで組み込みオブジェクト（ブルとインオブジェクト）と呼ばれる。
プロパティの値が関数の場合は、そのプロパティを特別にメソッドと呼ぶ。

配列の中にあるオブジェクトの値を取得する
配列[インデックス].キー
console.log(lists[0].name);

コードをスッキリさせる
for(let i = 0; i < lists.length; i++){
  const content = `<div><img src="images/${lists[i].img}" alt=""><h2>${lists[i].name}</h2><p>${lists[i].price}円</p></div>`;
  menu.insertAdjacentHTML('beforeend', content);
}

list[i]を何度も記述しているため、取得する値をそれぞれの定数にする。
for(let i = 0; i < lists.length; i++){
  const name = lists[i].name;
  const img = lists[i].img;
  const price = lists[i].price;
  const content = `<div><img src="images/${img}" alt=""><h2>${name}</h2><p>${price}円</p></div>`;
  menu.insertAdjacentHTML('beforeend', content);
}

分割代入を使い、1度に複数のプロパティの値を定数に代入できる。
const {キー1, キー2, キー3} = オブジェクト名;
for(let i = 0; i < lists.length; i++){
  const {name, img, price} = lists[i];
  const content = `<div><img src="images/${img}" alt=""><h2>${name}</h2><p>${price}円</p></div>`;
  menu.insertAdjacentHTML('beforeend', content);
}

配列とオブジェクトの使い分け
1.配列は単一の項目が順に並んでいるようなシンプルなデータで使う。
| 1 | Ken |
| 2 | Sato |
| 3 | Suzuki |
2.オブジェクトは複数の項目がある場合に使う。
| name | age | birthday   |
| Ken  | 27  | 1996/09/19 |
3.表計算の表のように複数の項目が順に並ぶようなデータであれば配列とオブジェクトを組み合わせて利用する。
| name   | age | birthday   |
| Ken    | 27  | 1996/09/19 |
| Sato   | 28  | 1995/11/11 |
| Suzuki | 25  | 1998/04/02 |

JavaScriptにあらかじめ用意されているブルとインオブジェクトのうち、Mathオブジェクトを使うと、数学的な計算ができるようになる。
| Math.floor(数値)            | 小数点以下切り捨て       | console.log(Math.floor(9.28)); | 9 
| Math.ceil(数値)             | 小数点以下切り上げ       | console.log(Math.ceil(9.28));  | 10 
| Math.round(数値)            | 四捨五入                | console.log(Math.round(9.28));  | 9 
| Math.random()               | 0以上1未満をランダム    | console.log(Math.random());     | 0.5567012735572743
| Math.pow(数値A, 数値B)      | AのB乗                  | console.log(Math.pow(9, 2));    | 81
| Math.max(数値A, 数値B, ~~~) | 最大値                  | console.log(Math.max(9,2,8));   | 9
| Math.pow(数値A, 数値B, ~~~) | 最小値                  | console.log(Math.min(9,2,8));   | 2
| Math.trunc(数値)            | 小数点以下切り捨て、整数 | console.log(Math.trunc(9.28));  | 9
